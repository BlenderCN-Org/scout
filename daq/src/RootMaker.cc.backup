#include <RootMaker.h>
#include <iostream>

RootMaker::RootMaker(std::string oname)
{
  this->ofile = new TFile(oname.c_str(), "RECREATE");
}

RootMaker::~RootMaker()
{
  this->ofile->Write();
  this->ofile->Close();
  //delete this->ofile;
  //delete this->gate;
  //delete this->waveform;
}
void RootMaker::setup_tree(uint32_t evts, uint32_t chans, uint32_t format, uint32_t samples)
{
  this->evts = evts;
  this->chans = chans;
  this->format = format;
  this->samples = samples;
  uint32_t num_gates = 0;
  if(format & 0b1)
    num_gates += 6;
  if(format & 0b10)
    num_gates += 2;
  this->gate = new unsigned long long*[chans];
  this->waveform = new unsigned long long*[chans];
  for(uint32_t i=0; i<chans; i++)
  {
    this->gate[i] = new unsigned long long[num_gates];
    this->waveform[i] = new unsigned long long[this->samples];
  }
  this->num_gates = num_gates;

  header_tree();
  dataTree = new TTree("Data", "Scout Data");
  dataTree->SetDirectory(this->ofile);
  dataTree->Branch("timestamp", &(this->timestamp), "timestamp/l");
  std::string gate_type = "gate[" + std::to_string(this->chans)
    + "][" + std::to_string(num_gates) + "]/l";
  dataTree->Branch("gate", this->gate, gate_type.c_str());
  std::string wave_type = "waveform[" + std::to_string(this->chans) + "]["
	+ std::to_string(this->samples) + "]/l";
  dataTree->Branch("waveform", this->waveform, wave_type.c_str());
}
/*
void RootMaker::setup_tree(uint32_t evts, uint32_t chans, uint32_t format, uint32_t samples)
{
  this->evts = evts;
  this->chans = chans;
  this->format = format;
  this->samples = samples;
  uint32_t num_gates = 0;
  if(format & 0b1)
    num_gates += 6;
  if(format & 0b10)
    num_gates += 2;
  this->gate = new UInt_t*[chans];
  for(uint32_t i=0; i<chans; i++)
    this->gate[i] = new UInt_t[num_gates];
  this->waveform = new int[samples];
  this->num_gates = num_gates;

  header_tree();
  dataTree = new TTree("Data", "Scout Data");
  dataTree->SetDirectory(this->ofile);
  dataTree->Branch("timestamp", &(this->timestamp), "this->timestamp/l");
  // Setup gate each as their own int as opposed to array, its just easier
  for(uint32_t ch=0; ch<chans; ch++)
    for(uint32_t gt=0; gt<num_gates; gt++)
    {
      std::string gatename = "ch" + std::to_string(ch) + "gt" + std::to_string(gt);
      dataTree->Branch(gatename.c_str(), &(this->gate[ch][gt]));
    }

  std::string wave_type = "this->waveform[" + std::to_string(this->samples) + "]/I";
  dataTree->Branch("waveform", this->waveform, wave_type.c_str());
}
*/

void RootMaker::header_tree()
{
  headerTree = new TTree("Header", "Run Information");
  headerTree->SetDirectory(this->ofile);
  headerTree->Branch("Events", &this->evts);
  headerTree->Branch("Channels", &this->chans);
  headerTree->Branch("Format", &this->format);
  headerTree->Branch("Samples", &this->samples);
  headerTree->Fill();
}

void RootMaker::load_event(event& ev)
{
  for(uint32_t ch=0; ch<this->chans; ch++)
  {
    channel cur_chan = ev.channels[ch];
    uint32_t ele = 0;
    this->timestamp = cur_chan.timestamp;
    if( this->format & 0b1 )
    {
      this->gate[ch][ele++] = static_cast<unsigned long long>(cur_chan.gate1);
      this->gate[ch][ele++] = static_cast<unsigned long long>(cur_chan.gate2);
      this->gate[ch][ele++] = static_cast<unsigned long long>(cur_chan.gate3);
      this->gate[ch][ele++] = static_cast<unsigned long long>(cur_chan.gate4);
      this->gate[ch][ele++] = static_cast<unsigned long long>(cur_chan.gate5);
      this->gate[ch][ele++] = static_cast<unsigned long long>(cur_chan.gate6);
    }
    if( this->format & 0b10 )
    {
      this->gate[ch][ele++] = static_cast<unsigned long long>(cur_chan.gate7);
      this->gate[ch][ele++] = static_cast<unsigned long long>(cur_chan.gate8);
    }
    for(uint32_t sam=0; sam < this->samples; sam++)
    {
      //this->waveform[ch][sam] = static_cast<unsigned long long>(cur_chan.waveform[sam]);
      this->waveform[ch][sam] = static_cast<unsigned long long>(cur_chan.waveform[sam]);
      std::cout << cur_chan.waveform[sam] << " =?= " << this->waveform[ch][sam] << std::endl;
    }
  }
  dataTree->Fill();
}

